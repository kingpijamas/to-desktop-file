#!/bin/bash

## Application defaults
declare -r DEFAULT_ENCODING="UTF-8"
IS_TERMINAL=false
STARTUP_NOTIFY=false
NO_DISPLAY=false
COMMENT="Default auto-generated comment. Please change this in the future."
TYPE="Application"

## implementation-specific vars - Do NOT change these
declare -a ACCEPTED_INSTALL_DIRECTORIES=( "/opt" , "/usr/local" , "/usr/bin" , "/usr/sbin" , "/bin" , "/sbin")
declare -r DEFAULT_HEADER="[Desktop Entry]\nEncoding=$DEFAULT_ENCODING\n"

declare -i EXIT_STATUS=1
declare -i TRUE=0
declare -i FALSE=1

## unset-vars
declare APP_NAME
declare INVOCATION_COMMAND
declare ICON
declare EXTRA_CATEGORIES
declare MIME_TYPES
declare BASE_DIR
declare TARGET_FILE

#The buffer to which all will be written before writing to disk
declare BUFFER

main() {
	if ! __parse_args "$@" ; then
		exit $EXIT_STATUS
	fi

	TARGET_FILE="/tmp/$APP_NAME.desktop"
	rm -f "$TARGET_FILE"

	__append "$DEFAULT_HEADER"
	__append_att_val "Name" "$APP_NAME"
	__append_att_val "Comment" "$COMMENT"
	__append_defaultable_att_val "Exec" "$BASE_DIR/$APP_NAME %u" "$INVOCATION_COMMAND"  
	__append_att_val "Terminal" "$IS_TERMINAL"
	__append_defaultable_att_val "Type" "$TYPE"
	__append_defaultable_att_val "Icon" "$BASE_DIR/$APP_NAME" "$ICON"
	__append_att_vals "Categories" "Application" "$EXTRA_CATEGORIES"
	__append_att_val "StartupNotify" "$STARTUP_NOTIFY"
	__append_optional_att_vals "MimeType" "$MIME_TYPES"
	__append_att_val "NoDisplay" "$NO_DISPLAY"

	echo -e "$BUFFER"
	echo -e "$BUFFER" >> "$TARGET_FILE"

	sudo desktop-file-install "$TARGET_FILE"
	rm "$TARGET_FILE"
}

## Prints the usage to stderr
usage() {
	local text="Usage: "
	text+=$(basename $0)
	text+=$(__to_usage_opt_string "f" "app-name")
	text+=$(__to_usage_opt_string "c" "comment")
	text+=$(__to_usage_opt_string "e" "invokation-command")
	text+=$(__to_usage_opt_string "T")
	text+=$(__to_usage_opt_string "t" "type")
	text+=$(__to_usage_opt_string "i" "path-to-icon")
	text+=$(__to_usage_opt_string "k" "extra-categories")
	text+=$(__to_usage_opt_string "S")
	text+=$(__to_usage_opt_string "o" "MIME-types-to-open")
	text+=$(__to_usage_opt_string "N")	
	text+=$(__to_usage_opt_string "h")
	text+=" [<arg>]"
	echo "$text" 1>&2
}

## Returns either TRUE or FALSE depending on the arguments validity. It parses options first, then parses the directory parameter. 
__parse_args() {
	if ! __parse_options "$@" || ! __parse_dir "${!#}"; then
		return $FALSE
	fi
}

## Returns either TRUE or FALSE depending on the options' validity (Please note that -h also returns false, since the program should not continue after printing the usage)
__parse_options() {
	while getopts "NTShf:c:e:t:i:k:o:" opt; do
		case $opt in
		f)	#Set the app name
			APP_NAME=$OPTARG;;
		c)	#Set the comment
			COMMENT=$OPTARG;;
		e)	#Set the command to run the application
			INVTRUEATION_COMMAND=$OPTARG;;
		T)	#Set the application to show on terminal
			IS_TERMINAL=true;;
		t)	#Add extra types for the application
			TYPE=$OPTARG;;
		i)	#Set the icon
			ICON=$OPTARG;;
		k)	#Set the extra categories for the application
			EXTRA_CATEGORIES=$OPTARG;;			
		S)	#Set the application to notify on startup
			STARTUP_NOTIFY=true;;
		o)	#Set the MimeTypes to be associated with this application
			MIME_TYPES=$OPTARG;;
		N)	#Set the application to not display
			NO_DISPLAY=true;;
		h)	#Prints the help and exits the application
			usage && return $FALSE;;
		:)	
			__print_error "Option -$OPTARG requires an argument."
			return $FALSE;;
		\?)
			__print_error "Unknown option: -$OPTARG"
			return $FALSE;;
	  	esac
	done
}

## Returns TRUE or FALSE depending on the directory's validity
__parse_dir() {
	# Parsing the directories
	BASE_DIR="$1"; shift
	if [ ! -d "$BASE_DIR" ]; then
		__print_error "$BASE_DIR is not a directory."
		return $FALSE
	elif [[ "$0" = /* ]]; then
		__print_error "$BASE_DIR is not an absolute path."
		return $FALSE
	elif ! __is_valid_path "$BASE_DIR"; then
		__print_error "$BASE_DIR is not a valid path. (Are you sure you wanted to install it there?)."
		return $FALSE
	fi
}

## Returns a nicer String representation for a required parameter's specification
__to_usage_opt_string() {
	local opt=$1;shift
	local arg=$1;shift
	if [ -z $arg ]; then
		echo " [-$opt]"
	else
		echo " [-$opt <$arg>]"
	fi
}

## Prints the parameter to std error
__print_error() {
	echo "$1" >&2
}

## Checks whether the argument is in one of the ACCEPTED_INSTALL_DIRECTORIES. Echoes false if it is not
__is_valid_path() {
	local install_dir=$1
	for possible_start in "${ACCEPTED_INSTALL_DIRECTORIES[@]}"; do
		if [[ "$install_dir" = "$possible_start"/* ]]; then			
			return $TRUE
		fi
	done
	return $FALSE
}

## If the values are not nil, it appends the attribute and its values
__append_optional_att_vals() {
	if [ $# -gt 1 ] && [ ! -z $2 ]; then
		__append_att_vals "$@"
	fi
}

## If the value passed to this function is nil, then it replaces it with a default one.
__append_defaultable_att_val() {
	local attribute=$1;shift
	local default_value=$1;shift
	local value=$1;shift

	if [ -z $value ]; then
		value="$default_value"
	fi

	__append_att_val "$attribute" "$value"
}

## Appends an attribute with a single value
__append_att_val() {
	local attribute=$1; shift
	__append "$attribute="
	__append "$1\n"
}

## Appends an attribute with multiple values
__append_att_vals() {
	local attribute=$1; shift
	__append "$attribute="
	__append_vals "$@"
}

## Writes the successive semicolon-separated values
__append_vals(){
	while [ $# -gt 0 ]
	do
		if [ ! -z "$1" ]; then
			__append "$1;"
		fi
		shift
	done
	__append "\n"
}

## Appends the parameter to the buffer
__append() {
	BUFFER+="$1"
}

main "$@"
